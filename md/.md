この記事は[ウェブクルー Advent Calendar 2017](https://qiita.com/advent-calendar/2017/webcrew)の1日目の記事です。

## 概要
4月からPlayFramework, Scala を業務で使い始めたので、まとめとしてCRUDを実装したメモアプリ（Knowledgeのすごく簡単な感じのやつ）を作成しました。
joinやtransaction等も実装したので、これからPlayFramework, Slick に入門する方の助けになればと思います。

## 環境
- OS : MacOS
- JVM : Java8
- Scala : 2.12.3
- sbt : 1.0.3
- PlayFramework : 2.6.7
- Database : Mysql

## テーブル構成
- Memo
 - タイトル、メモ内容を格納しています。primary key が auto_increment になっています。
- TagMst
 - メモに付けられるタグのマスタです。primary key が auto_increment になっています。
- TagMapping
 - メモとタグのひも付きを格納しています。

## プロジェクト作成
まずはプロジェクトを作成します。
Play2.5ではTypesafe activatorを使っていましたが、Play2.6ではsbtを使います。
プロジェクトを作りたいディレクトリに移動して以下のコマンドを実行します。

`sbt new playframework/play-scala-seed.g8`

するとjarのダウンロードが始まり、最後に以下の内容を聞かれます。
特に変更しない場合はEnter連打でOKです。
その場合は、`[]` の中に表示されている内容でプロジェクトを作成します。

```
name [play-scala-seed]: play_example
organization [com.example]:
play_version [2.6.7]:
sbt_version [1.0.2]:
scalatestplusplay_version [3.1.2]:
```

コマンドが終了するとカレントディレクトリに、Play のプロジェクトが作成されます。

## 設定
依存するライブラリやビルドの設定を行います。

### 依存するライブラリの設定
DBの操作にSlickを使うので build.sbt に以下のライブラリ依存性を追加します。

```sbt:build.sbt
libraryDependencies ++= Seq(
  "com.typesafe.play" %% "play-slick" % "3.0.2",
  "com.typesafe.slick" %% "slick-codegen" % "3.2.1",
  "mysql" % "mysql-connector-java" % "5.1.42"
)
```

### sbtプラグインの設定 - plugins.sbt
eclipseを使って開発しましたので、以下のpluginを追加します。

```sbt:plugins.sbt
addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin" % "5.2.3")
```

これで、`sbt eclipse`が使えるようになり、eclipseにプロジェクトをインポート出来るようになります。

### ビルドの設定 - build.properties
buildに使うsbtのバージョンを設定します。
`sbt.version=1.0.2` がプロジェクト作成時に設定されていましたが、`sbt 1.0.3`が出ているので`1.0.3`に変更しました。

```properties:build.properties
sbt.version=1.0.3
```

## Model と Dao
modelとdaoを作成します。
modelはbuild.sbtで設定した`slick-codegen`を用いて生成します。
以下が`slick-codegen`を使ってModelを生成するscalaアプリケーションになります。

### Model

- ModelのGenerator

```scala:SlickModelGenerator.scala
package genarator

import scala.concurrent.Await
import scala.concurrent.ExecutionContext
import scala.concurrent.duration.Duration

import slick.codegen.SourceCodeGenerator
import slick.jdbc.meta.MTable
import slick.model.Model

object SlickModelGenerator extends App {

  // 接続先
  val url = "jdbc:mysql://localhost/memo"
  // 出力するディレクトリ
  val outputDir = "app"
  // 出力するパッケージ
  val pkg = "models"
  // traitの名前
  val topTraitName = "Tables"
  // ファイル名
  val scalaFileName = "Tables.scala"
  // 生成するテーブルを指定、今回は全テーブルModelを作成するのでNone
  val tableNames: Option[Seq[String]] = None

  val slickProfile = "slick.jdbc.MySQLProfile"
  val profile = slick.jdbc.MySQLProfile
  val db = profile.api.Database.forURL(url, driver = "com.mysql.jdbc.Driver", user = "memo", password = "memo")

  try {
    import scala.concurrent.ExecutionContext.Implicits.global
    val mTablesAction = MTable.getTables.map { _.map { mTable => mTable.copy(name = mTable.name.copy(catalog = None)) } }

    val allModel = Await.result(db.run(profile.createModel(Some(mTablesAction), false)(ExecutionContext.global).withPinnedSession), Duration.Inf)

    val modelFiltered = tableNames.fold(allModel) { tableNames =>
      Model(tables = allModel.tables.filter { aTable =>
        tableNames.contains(aTable.name.table)
      })
    }

    new SourceCodeGeneratorEx(modelFiltered).writeToFile(slickProfile, outputDir, pkg, topTraitName, scalaFileName)
  } finally db.close

  class SourceCodeGeneratorEx(model: Model) extends SourceCodeGenerator(model) {
    override def Table = new Table(_) {
      //auto_incrementを識別できるようにする
      //生成されるモデルはOption型になる
      override def autoIncLastAsOption = true
      override def Column = new Column(_) {
        override def rawType = model.tpe match {
          case "java.sql.Blob" =>
            "Array[Byte]"
          case _ =>
            super.rawType
        }
      }
    }
  }
}
```

- 生成されたModel

```scala:Tables.scala
package models
// AUTO-GENERATED Slick data model
/** Stand-alone Slick data model for immediate use */
object Tables extends {
  val profile = slick.jdbc.MySQLProfile
} with Tables

/** Slick data model trait for extension, choice of backend or usage in the cake pattern. (Make sure to initialize this late.) */
trait Tables {
  val profile: slick.jdbc.JdbcProfile
  import profile.api._
  import slick.model.ForeignKeyAction
  // NOTE: GetResult mappers for plain SQL are only generated for tables where Slick knows how to map the types of all columns.
  import slick.jdbc.{GetResult => GR}

  /** DDL for all tables. Call .create to execute. */
  lazy val schema: profile.SchemaDescription = Memo.schema ++ TagMapping.schema ++ TagMst.schema
  @deprecated("Use .schema instead of .ddl", "3.0")
  def ddl = schema

  /** Entity class storing rows of table Memo
   *  @param title Database column title SqlType(VARCHAR), Length(200,true)
   *  @param mainText Database column main_text SqlType(VARCHAR), Length(10000,true), Default(None)
   *  @param upadtedAt Database column upadted_at SqlType(DATETIME), Default(None)
   *  @param createdAt Database column created_at SqlType(DATETIME)
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey */
  case class MemoRow(title: String, mainText: Option[String] = None, upadtedAt: Option[java.sql.Timestamp] = None, createdAt: java.sql.Timestamp, id: Option[Int] = None)
  /** GetResult implicit for fetching MemoRow objects using plain SQL queries */
  implicit def GetResultMemoRow(implicit e0: GR[String], e1: GR[Option[String]], e2: GR[Option[java.sql.Timestamp]], e3: GR[java.sql.Timestamp], e4: GR[Option[Int]]): GR[MemoRow] = GR{
    prs => import prs._
    val r = (<<?[Int], <<[String], <<?[String], <<?[java.sql.Timestamp], <<[java.sql.Timestamp])
    import r._
    MemoRow.tupled((_2, _3, _4, _5, _1)) // putting AutoInc last
  }
  /** Table description of table memo. Objects of this class serve as prototypes for rows in queries. */
  class Memo(_tableTag: Tag) extends profile.api.Table[MemoRow](_tableTag, "memo") {
    def * = (title, mainText, upadtedAt, createdAt, Rep.Some(id)) <> (MemoRow.tupled, MemoRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (Rep.Some(title), mainText, upadtedAt, Rep.Some(createdAt), Rep.Some(id)).shaped.<>({r=>import r._; _1.map(_=> MemoRow.tupled((_1.get, _2, _3, _4.get, _5)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column title SqlType(VARCHAR), Length(200,true) */
    val title: Rep[String] = column[String]("title", O.Length(200,varying=true))
    /** Database column main_text SqlType(VARCHAR), Length(10000,true), Default(None) */
    val mainText: Rep[Option[String]] = column[Option[String]]("main_text", O.Length(10000,varying=true), O.Default(None))
    /** Database column upadted_at SqlType(DATETIME), Default(None) */
    val upadtedAt: Rep[Option[java.sql.Timestamp]] = column[Option[java.sql.Timestamp]]("upadted_at", O.Default(None))
    /** Database column created_at SqlType(DATETIME) */
    val createdAt: Rep[java.sql.Timestamp] = column[java.sql.Timestamp]("created_at")
    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
  }
  /** Collection-like TableQuery object for table Memo */
  lazy val Memo = new TableQuery(tag => new Memo(tag))

  /** Entity class storing rows of table TagMapping
   *  @param memoId Database column memo_id SqlType(INT), Default(None)
   *  @param tagId Database column tag_id SqlType(INT), Default(None) */
  case class TagMappingRow(memoId: Option[Int] = None, tagId: Option[Int] = None)
  /** GetResult implicit for fetching TagMappingRow objects using plain SQL queries */
  implicit def GetResultTagMappingRow(implicit e0: GR[Option[Int]]): GR[TagMappingRow] = GR{
    prs => import prs._
    val r = (<<?[Int], <<?[Int])
    import r._
    TagMappingRow.tupled((_1, _2)) // putting AutoInc last
  }
  /** Table description of table tag_mapping. Objects of this class serve as prototypes for rows in queries. */
  class TagMapping(_tableTag: Tag) extends profile.api.Table[TagMappingRow](_tableTag, "tag_mapping") {
    def * = (memoId, tagId) <> (TagMappingRow.tupled, TagMappingRow.unapply)

    /** Database column memo_id SqlType(INT), Default(None) */
    val memoId: Rep[Option[Int]] = column[Option[Int]]("memo_id", O.Default(None))
    /** Database column tag_id SqlType(INT), Default(None) */
    val tagId: Rep[Option[Int]] = column[Option[Int]]("tag_id", O.Default(None))

    /** Index over (memoId) (database name memo_id) */
    val index1 = index("memo_id", memoId)
    /** Index over (tagId) (database name tag_id) */
    val index2 = index("tag_id", tagId)
  }
  /** Collection-like TableQuery object for table TagMapping */
  lazy val TagMapping = new TableQuery(tag => new TagMapping(tag))

  /** Entity class storing rows of table TagMst
   *  @param name Database column name SqlType(VARCHAR), Length(100,true), Default(None)
   *  @param id Database column id SqlType(INT), AutoInc, PrimaryKey */
  case class TagMstRow(name: Option[String] = None, id: Option[Int] = None)
  /** GetResult implicit for fetching TagMstRow objects using plain SQL queries */
  implicit def GetResultTagMstRow(implicit e0: GR[Option[String]], e1: GR[Option[Int]]): GR[TagMstRow] = GR{
    prs => import prs._
    val r = (<<?[Int], <<?[String])
    import r._
    TagMstRow.tupled((_2, _1)) // putting AutoInc last
  }
  /** Table description of table tag_mst. Objects of this class serve as prototypes for rows in queries. */
  class TagMst(_tableTag: Tag) extends profile.api.Table[TagMstRow](_tableTag, "tag_mst") {
    def * = (name, Rep.Some(id)) <> (TagMstRow.tupled, TagMstRow.unapply)
    /** Maps whole row to an option. Useful for outer joins. */
    def ? = (name, Rep.Some(id)).shaped.<>({r=>import r._; _2.map(_=> TagMstRow.tupled((_1, _2)))}, (_:Any) =>  throw new Exception("Inserting into ? projection not supported."))

    /** Database column name SqlType(VARCHAR), Length(100,true), Default(None) */
    val name: Rep[Option[String]] = column[Option[String]]("name", O.Length(100,varying=true), O.Default(None))
    /** Database column id SqlType(INT), AutoInc, PrimaryKey */
    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
  }
  /** Collection-like TableQuery object for table TagMst */
  lazy val TagMst = new TableQuery(tag => new TagMst(tag))
}
```

### Dao
ここまででModelを生成しました。次はDaoを作成していきます。
Daoにはメモの検索、id指定検索、登録、更新、削除を実装しました。

- 検索  
検索条件のmainTextが指定されていればメモをlike検索、指定されていなければ全検索します。  
メモに付いているタグも取得しています。  
`sortBy(_.id)`でidの順にソートした結果を返すクエリになります。  
`filter(_.mainText like s"%${mainText}%"`でlike検索するクエリになります。  
`join`で内部結合になります。他に`joinFull`, `joinLeft`, `joinRight` があります。

```scala:dao.MemoDao.scala
  def search(mainText: Option[String]) = {
    // クエリを作成
    val query = for {
      // 検索条件が指定されていれば条件を使って検索、指定されていないなら全件取得
      memos <- mainText.fold(Memo.sortBy(_.id))(mainText => Memo.filter(_.mainText like s"%${mainText}%").sortBy(_.id)).result
        .map(_.map(memo => MemoItem(memo.id.getOrElse(-1), memo.title, memo.mainText.getOrElse(""))))

      // 取得したメモに紐づくタグを取得する
      tags <- Memo.filter(_.id.inSetBind(memos.map(_.id)))
        .join(TagMapping).on((m, t) => m.id === t.memoId)
        .join(TagMst).on((mt, tm) => mt._2.tagId === tm.id)
        .map(result => (result._1._1.id, result._2)).result
    } yield memos.map(memo =>
      MemoInfo(memo.id, memo.title, memo.mainText, tags.filter(tagMap => tagMap._1 == memo.id).map(_._2)))

    db.run(query)
  }
```
 
- 登録  
入力内容を元にメモの登録、タグの登録、メモとタグのひも付きを登録します。  
`Memo Memo returning Memo.map(_.id) += MemoRow(…)`でメモの登録になります。  
`Memo += MemoRow(…)`でも登録できるのですが、↑の実装だとオートインクリメントで発行されたIDを取得できるので、必要に応じて使い分けていけば良いと思います。  
`transactionally`で一連の更新系クエリを一つのトランザクションになります。  
以下のコードで言うと3行目の`for`式の中のクエリが一つのトランザクションになります。

```scala:dao.MemoDao.scala
  def create(form: MemoForm) = {
    // トランザクションを作成
    val transaction = (for {
      // メモを登録してidを取得
      memoId <- Memo returning Memo.map(_.id) += MemoRow(form.title, form.mainText, None, new Timestamp(System.currentTimeMillis()))

      // ひも付けられたタグがマスタに存在しない場合、タグを登録
      _ <- DBIO.sequence(form.tags.map(tag =>
        TagMst.filter(_.name === tag).exists.result.flatMap {
          case true => DBIO.successful(0)
          case false => (TagMst returning TagMst.map(_.id) += TagMstRow(Some(tag))).map(DBIO.successful(_)).flatten
        }))

      // メモとタグのマッピングを登録
      _ <- TagMst.filter(_.name.inSetBind(form.tags)).result.flatMap(tags =>
        TagMapping ++= tags.map(tag => TagMappingRow(Some(memoId), tag.id)))
    } yield memoId).transactionally

    db.run(transaction)
  }
```

- 更新


- 説明する内容
 - ~~Modelの自動生成~~
 - Slickの使い方
  - ~~Insert~~
  - ~~Select~~
  - ~~Join~~
  - Update
  - Delete

- 載せるコード
 - ~~Dao~~
 - ~~Model~~

## View

説明する内容
scalaコードの埋め込みかた

載せるコード
twirl

## Controller
説明
Controllerの実装方法

載せるコード
Controller
routes

## 最後に
一通りCRUDの実装について書いてみましたが、PlayFrameworkの機能は他にも数多くあります。
公式のドキュメントが充実しているので、一度目を通しておくのがおすすめです。（英語ですがコードも載っているので分かりやすいです）
この記事で使っているPlayのプロジェクトは[Github](https://github.com/kouares/play_example)にあります。
SlickのModelを自動生成しているコードとかもありますので興味があれば見てください。

以上、PlayFrameworkを始めた OR 始める予定のエンジニアの助けになれば幸いです。

明日は[@hahegawa](https://qiita.com/hahegawa)さんです。よろしくお願いします！

ウェブクルーでは一緒に働いていただける方を随時募集しております。
お気軽にエントリーくださいませ。

[開発エンジニアの募集](https://hrmos.co/pages/1004681658307198976/jobs/0000005)
[フロントエンドエンジニアの募集](http://www.webcrew.co.jp/recruit/creative.html)
[データベースエンジニアの募集](https://hrmos.co/pages/1004681658307198976/jobs/0000023)
